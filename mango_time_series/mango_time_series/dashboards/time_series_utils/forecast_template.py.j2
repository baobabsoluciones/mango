from typing import Dict, Union

from statsforecast import StatsForecast
from statsforecast.models import (

{ % -
for model_class in all_imports -%}
{{model_class}}{% if not loop.last %}, {%endif %}
{% - endfor - %}
)

# Crear el diccionario `default_models` con instancias de modelos
default_models: Dict[str, Union[
    {%- for model in models -%}
    {{ model.class_name }}{% if not loop.last %}, {% endif %}
    {%- endfor -%}
]] = {
    {%- for model in models -%}
    "{{ model.name }}": {{ model.class_name }}(
        {%- for param_name, param_value in model.parameters.items() -%}
        {%- if param_name != 'alias' -%}
        {{ param_name }}=
        {%- if param_value.__class__.__module__ == "statsforecast.models" -%}
            {{ param_value.__class__.__name__ }}()  {# Agrega `()` para instanciar la clase #}
        {%- else -%}
            {{ param_value }} {# No es una clase de modelo, solo usa el valor tal cual #}
        {%- endif -%}
        {% if not loop.last %}, {% endif %}
        {%- endif -%}
        {%- endfor -%}
    ){% if not loop.last %}, {% endif %}
    {%- endfor -%}
}

class ForecastModel:
    def __init__(self, models=default_models, horizon={{ horizon }}, step_size={{ step_size }}, n_windows={{ n_windows }}, freq="{{ freq_code }}"):
        self.models = models
        self.horizon = horizon
        self.step_size = step_size
        self.n_windows = n_windows
        self.freq = freq

    def prepare_data(self, df, columns_id=None):
        df = df.copy()
        if not columns_id:
            df["unique_id"] = "id_1"
            columns_id = "unique_id"
        df = df.rename(columns={"datetime": "ds", "y": "y"})
        return df, columns_id

    def run_forecast(self, df, columns_id=None):
        time_series, columns_id = self.prepare_data(df, columns_id)
        fcst = StatsForecast(models=list(self.models.values()), freq=self.freq)

        crossvalidation_df = fcst.cross_validation(
            df=time_series,
            h=self.horizon,
            step_size=self.step_size,
            n_windows=self.n_windows,
            id_col=columns_id,
        )

        return crossvalidation_df
